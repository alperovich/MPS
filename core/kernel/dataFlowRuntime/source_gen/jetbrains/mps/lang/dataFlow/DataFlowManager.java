package jetbrains.mps.lang.dataFlow;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.classloading.MPSClassesListener;
import jetbrains.mps.classloading.MPSClassesListenerAdapter;
import java.util.Set;
import jetbrains.mps.module.ReloadableModuleBase;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.lang.dataFlow.framework.Program;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.util.SNodeOperations;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

/**
 * 
 * @deprecated use {@link jetbrains.mps.lang.dataFlow.MPSProgramBuilder } directly to build program
 */
@Deprecated
@ToRemove(version = 3.4)
public class DataFlowManager implements CoreComponent {
  private static DataFlowManager INSTANCE;
  private final ClassLoaderManager myManager;
  private final MPSClassesListener myListener = new MPSClassesListenerAdapter() {
    @Override
    public void beforeClassesUnloaded(Set<? extends ReloadableModuleBase> modules) {
      DataFlowManager.this.clear();
    }
  };
  private Map<String, DataFlowBuilder> myBuilders = new HashMap<String, DataFlowBuilder>();
  private boolean myLoaded = false;

  @Deprecated
  public DataFlowManager(MPSModuleRepository moduleRepository, ClassLoaderManager manager) {
    myManager = manager;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myManager.addClassesHandler(myListener);
  }
  @Override
  public void dispose() {
    myManager.removeClassesHandler(myListener);
    INSTANCE = null;
  }
  public void register(String conceptFqName, DataFlowBuilder builder) {
    this.myBuilders.put(conceptFqName, builder);
  }
  public Program buildProgramFor(SNode node) {
    checkLoaded();
    return new MPSProgramBuilder(this).buildProgram(node);
  }

  /*package*/ DataFlowBuilder getBuilderFor(String concept) {
    checkLoaded();
    return this.myBuilders.get(concept);
  }
  private void clear() {
    myBuilders.clear();
    myLoaded = false;
  }
  private synchronized void checkLoaded() {
    if (myLoaded) {
      return;
    }
    myLoaded = true;
    this.load();
  }
  private void load() {
    for (Language l : ModuleRepositoryFacade.getInstance().getAllModules(Language.class)) {
      SModel dfaModel = LanguageAspect.DATA_FLOW.get(l);
      if (dfaModel != null && dfaModel.getRootNodes().iterator().hasNext()) {
        String dfaBuildersClassName = SNodeOperations.getModelLongName(dfaModel) + ".DFABuilders";
        Class<? extends DataFlowBuilders> buildersClass = null;
        try {
          buildersClass = ((Class<? extends DataFlowBuilders>) l.getOwnClass(dfaBuildersClassName));
        } catch (ClassNotFoundException ignored) {
        }
        if (buildersClass != null) {
          try {
            DataFlowBuilders builders = buildersClass.newInstance();
            builders.install(this);
          } catch (InstantiationException e) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("", e);
            }
          } catch (IllegalAccessException e) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("", e);
            }
          }
        }
      }
    }
  }
  public static DataFlowManager getInstance() {
    return INSTANCE;
  }
  protected static Logger LOG = LogManager.getLogger(DataFlowManager.class);
}
